"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const node_assert_1 = __importDefault(require("node:assert"));
const node_fs_1 = __importDefault(require("node:fs"));
const graphql_language_service_1 = require("graphql-language-service");
const node_path_1 = __importDefault(require("node:path"));
const GRAPHQL_SUCCESS_CODE = 0;
const GRAPHQL_FAILURE_CODE = 1;
function main(command, argv) {
    var _a, _b;
    const filePath = (_a = argv.file) === null || _a === void 0 ? void 0 : _a.trim();
    (0, node_assert_1.default)(argv.text || argv.file, 'A path to the GraphQL file or its contents is required.');
    const text = ensureText(argv.text, filePath);
    const schemaPath = (_b = argv.schemaPath) === null || _b === void 0 ? void 0 : _b.trim();
    let exitCode;
    switch (command) {
        case 'autocomplete':
            const lines = text.split('\n');
            const row = parseInt(argv.row, 10) || lines.length - 1;
            const column = parseInt(argv.column, 10) || lines.at(-1).length;
            const point = new graphql_language_service_1.Position(row, column);
            exitCode = _getAutocompleteSuggestions(text, point, schemaPath);
            break;
        case 'outline':
            exitCode = _getOutline(text);
            break;
        case 'validate':
            exitCode = _getDiagnostics(filePath, text, schemaPath);
            break;
        default:
            throw new Error(`Unknown command '${command}'`);
    }
    process.exit(exitCode);
}
exports.default = main;
function formatUnknownError(error) {
    let message;
    if (error instanceof Error) {
        message = error.stack;
    }
    return message !== null && message !== void 0 ? message : String(error);
}
function _getAutocompleteSuggestions(queryText, point, schemaPath) {
    (0, node_assert_1.default)(schemaPath, 'A schema path is required to provide GraphQL autocompletion');
    try {
        const schema = schemaPath ? generateSchema(schemaPath) : null;
        const resultArray = schema
            ? (0, graphql_language_service_1.getAutocompleteSuggestions)(schema, queryText, point)
            : [];
        const resultObject = resultArray.reduce((prev, cur, index) => {
            prev[index] = cur;
            return prev;
        }, {});
        process.stdout.write(JSON.stringify(resultObject, null, 2));
        return GRAPHQL_SUCCESS_CODE;
    }
    catch (error) {
        process.stderr.write(formatUnknownError(error) + '\n');
        return GRAPHQL_FAILURE_CODE;
    }
}
function _getDiagnostics(_filePath, queryText, schemaPath) {
    try {
        const schema = schemaPath ? generateSchema(schemaPath) : null;
        const resultArray = (0, graphql_language_service_1.getDiagnostics)(queryText, schema);
        const resultObject = resultArray.reduce((prev, cur, index) => {
            prev[index] = cur;
            return prev;
        }, {});
        process.stdout.write(JSON.stringify(resultObject, null, 2));
        return GRAPHQL_SUCCESS_CODE;
    }
    catch (error) {
        process.stderr.write(formatUnknownError(error) + '\n');
        return GRAPHQL_FAILURE_CODE;
    }
}
function _getOutline(queryText) {
    try {
        const outline = (0, graphql_language_service_1.getOutline)(queryText);
        if (outline) {
            process.stdout.write(JSON.stringify(outline, null, 2));
        }
        else {
            throw new Error('Error parsing or no outline tree found');
        }
    }
    catch (error) {
        process.stderr.write(formatUnknownError(error) + '\n');
        return GRAPHQL_FAILURE_CODE;
    }
    return GRAPHQL_SUCCESS_CODE;
}
function ensureText(queryText, filePath) {
    let text = queryText;
    if (!text) {
        try {
            text = node_fs_1.default.readFileSync(filePath, 'utf8');
        }
        catch (error) {
            throw new Error(String(error));
        }
    }
    return text;
}
function generateSchema(schemaPath) {
    const schemaDSL = node_fs_1.default.readFileSync(schemaPath, 'utf8');
    const schemaFileExt = node_path_1.default.extname(schemaPath);
    switch (schemaFileExt) {
        case '.graphql':
            return (0, graphql_1.buildSchema)(schemaDSL);
        case '.json':
            return (0, graphql_1.buildClientSchema)(JSON.parse(schemaDSL));
        default:
            throw new Error('Unsupported schema file extension');
    }
}
//# sourceMappingURL=client.js.map